<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riftbound Sideboard Guide</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* Force scrollbar to always show to prevent layout shift */
        html {
            overflow-y: scroll;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        function RiftboundSideboardGuide() {
            const [deckName, setDeckName] = useState('');
            const [legendCard, setLegendCard] = useState('');
            const [mainDeck, setMainDeck] = useState([]);
            const [sideboard, setSideboard] = useState([]);
            const [battlefields, setBattlefields] = useState([]);
            const [runes, setRunes] = useState([]);
            const [matchups, setMatchups] = useState([]);
            const [currentCard, setCurrentCard] = useState({ name: '', count: 1 });
            const [currentMatchup, setCurrentMatchup] = useState({ name: '', battlefield: '', playOrder: 'first', sideboardPlan: [] });
            const [activeTab, setActiveTab] = useState('deck');
            const [editingMatchup, setEditingMatchup] = useState(null);
            const [showImport, setShowImport] = useState(false);
            const [importText, setImportText] = useState('');
            const [savedDecks, setSavedDecks] = useState([]);
            const [showLoadDeck, setShowLoadDeck] = useState(false);
            const [exportMode, setExportMode] = useState('guide'); // 'guide' or 'full'

            // Load saved decks list from localStorage
            useEffect(() => {
                const saved = localStorage.getItem('riftboundSavedDecks');
                if (saved) {
                    setSavedDecks(JSON.parse(saved));
                }
            }, []);

            // Save to localStorage whenever current deck changes
            useEffect(() => {
                // Don't auto-save if deck is empty
                if (!deckName && mainDeck.length === 0 && sideboard.length === 0) return;
                
                localStorage.setItem('riftboundCurrentDeck', JSON.stringify({
                    deckName,
                    legendCard,
                    mainDeck,
                    sideboard,
                    battlefields,
                    runes,
                    matchups
                }));
            }, [deckName, legendCard, mainDeck, sideboard, battlefields, runes, matchups]);

            // Load last worked on deck
            useEffect(() => {
                const saved = localStorage.getItem('riftboundCurrentDeck');
                if (saved) {
                    const data = JSON.parse(saved);
                    setDeckName(data.deckName || '');
                    setLegendCard(data.legendCard || '');
                    setMainDeck(data.mainDeck || []);
                    setSideboard(data.sideboard || []);
                    setBattlefields(data.battlefields || []);
                    setRunes(data.runes || []);
                    setMatchups(data.matchups || []);
                }
            }, []);

            const addCard = (isDeckList) => {
                if (!currentCard.name.trim()) return;
                
                const card = { 
                    name: currentCard.name.trim(), 
                    count: parseInt(currentCard.count) || 1 
                };
                
                if (isDeckList) {
                    setMainDeck([...mainDeck, card]);
                } else {
                    setSideboard([...sideboard, card]);
                }
                
                setCurrentCard({ name: '', count: 1 });
            };

            const removeCard = (index, isDeckList) => {
                if (isDeckList) {
                    setMainDeck(mainDeck.filter((_, i) => i !== index));
                } else {
                    setSideboard(sideboard.filter((_, i) => i !== index));
                }
            };

            const startNewMatchup = () => {
                setEditingMatchup({ name: '', battlefield: '', playOrder: '', sideboardPlan: [] });
                setActiveTab('matchup');
            };

            const addSideboardChange = (type) => {
                const plan = editingMatchup ? [...editingMatchup.sideboardPlan] : [...currentMatchup.sideboardPlan];
                plan.push({ type, card: '', count: 1 });
                
                if (editingMatchup) {
                    setEditingMatchup({ ...editingMatchup, sideboardPlan: plan });
                } else {
                    setCurrentMatchup({ ...currentMatchup, sideboardPlan: plan });
                }
            };

            const updateSideboardChange = (index, field, value) => {
                const plan = editingMatchup ? [...editingMatchup.sideboardPlan] : [...currentMatchup.sideboardPlan];
                plan[index] = { ...plan[index], [field]: value };
                
                if (editingMatchup) {
                    setEditingMatchup({ ...editingMatchup, sideboardPlan: plan });
                } else {
                    setCurrentMatchup({ ...currentMatchup, sideboardPlan: plan });
                }
            };

            const removeSideboardChange = (index) => {
                const plan = editingMatchup 
                    ? editingMatchup.sideboardPlan.filter((_, i) => i !== index)
                    : currentMatchup.sideboardPlan.filter((_, i) => i !== index);
                
                if (editingMatchup) {
                    setEditingMatchup({ ...editingMatchup, sideboardPlan: plan });
                } else {
                    setCurrentMatchup({ ...currentMatchup, sideboardPlan: plan });
                }
            };

            const saveMatchup = () => {
                const matchup = editingMatchup || currentMatchup;
                if (!matchup.name.trim()) {
                    alert('Please enter an opponent champion name!');
                    return;
                }
                
                // Calculate total cards going out and in
                const totalOut = matchup.sideboardPlan
                    .filter(change => change.type === 'out')
                    .reduce((sum, change) => sum + (parseInt(change.count) || 0), 0);
                
                const totalIn = matchup.sideboardPlan
                    .filter(change => change.type === 'in')
                    .reduce((sum, change) => sum + (parseInt(change.count) || 0), 0);
                
                // Validate equal cards out and in
                if (totalOut !== totalIn) {
                    alert(`Cards must be equal!\n\nCards Out: ${totalOut}\nCards In: ${totalIn}\n\nYou need to ${totalOut > totalIn ? 'add ' + (totalOut - totalIn) + ' more card(s) in' : 'remove ' + (totalIn - totalOut) + ' card(s) in or add more out'}.`);
                    return;
                }
                
                if (editingMatchup && editingMatchup.originalIndex !== undefined) {
                    const updated = [...matchups];
                    updated[editingMatchup.originalIndex] = { 
                        name: matchup.name,
                        battlefield: matchup.battlefield || '',
                        playOrder: matchup.playOrder || '',
                        sideboardPlan: matchup.sideboardPlan 
                    };
                    setMatchups(updated);
                } else {
                    setMatchups([...matchups, { 
                        name: matchup.name, 
                        battlefield: matchup.battlefield || '',
                        playOrder: matchup.playOrder || '',
                        sideboardPlan: matchup.sideboardPlan 
                    }]);
                }
                
                setCurrentMatchup({ name: '', battlefield: '', playOrder: '', sideboardPlan: [] });
                setEditingMatchup(null);
                setActiveTab('matchups');
            };

            const editMatchup = (index) => {
                setEditingMatchup({ ...matchups[index], originalIndex: index });
                setActiveTab('matchup');
            };

            const deleteMatchup = (index) => {
                if (confirm('Delete this matchup?')) {
                    setMatchups(matchups.filter((_, i) => i !== index));
                }
            };

            const saveDeck = () => {
                if (!deckName.trim()) {
                    alert('Please enter a deck name before saving!');
                    return;
                }
                
                const deckData = {
                    name: deckName,
                    legendCard,
                    mainDeck,
                    sideboard,
                    battlefields,
                    runes,
                    matchups,
                    savedAt: new Date().toISOString()
                };
                
                // Check if deck with this name already exists
                const existingIndex = savedDecks.findIndex(d => d.name === deckName);
                let newSavedDecks;
                
                if (existingIndex >= 0) {
                    // Update existing deck
                    newSavedDecks = [...savedDecks];
                    newSavedDecks[existingIndex] = deckData;
                } else {
                    // Add new deck
                    newSavedDecks = [...savedDecks, deckData];
                }
                
                setSavedDecks(newSavedDecks);
                localStorage.setItem('riftboundSavedDecks', JSON.stringify(newSavedDecks));
                alert(`Deck "${deckName}" saved successfully!`);
            };
            
            const loadDeck = (deck) => {
                setDeckName(deck.name);
                setLegendCard(deck.legendCard || '');
                setMainDeck(deck.mainDeck);
                setSideboard(deck.sideboard);
                setBattlefields(deck.battlefields || []);
                setRunes(deck.runes || []);
                setMatchups(deck.matchups);
                setShowLoadDeck(false);
                setActiveTab('deck');
            };
            
            const deleteDeck = (deckName) => {
                if (confirm(`Delete "${deckName}"? This cannot be undone.`)) {
                    const newSavedDecks = savedDecks.filter(d => d.name !== deckName);
                    setSavedDecks(newSavedDecks);
                    localStorage.setItem('riftboundSavedDecks', JSON.stringify(newSavedDecks));
                }
            };
            
            const clearDeck = () => {
                if (confirm('Clear current deck? This will remove all cards, matchups, and deck name.')) {
                    setDeckName('');
                    setLegendCard('');
                    setMainDeck([]);
                    setSideboard([]);
                    setBattlefields([]);
                    setRunes([]);
                    setMatchups([]);
                }
            };

            const importDeck = () => {
                if (!importText.trim()) return;
                
                const lines = importText.split('\n').map(line => line.trim());
                let newMainDeck = [];
                let newSideboard = [];
                let newBattlefields = [];
                let newRunes = [];
                let championName = '';
                let newLegendCard = '';
                
                let lineIndex = 0;
                let blankLinesSeen = 0;
                let cardsInCurrentSection = 0;
                
                // State machine: legend -> champion -> main -> battlefield -> rune -> sideboard
                let state = 'legend';
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Check for sideboard section
                    if (line.toLowerCase() === 'sideboard:') {
                        state = 'sideboard';
                        continue;
                    }
                    
                    // Handle blank lines
                    if (!line) {
                        if (state === 'legend') {
                            state = 'champion';
                        } else if (state === 'champion') {
                            state = 'main';
                        } else if (state === 'main' && cardsInCurrentSection > 0) {
                            state = 'battlefield';
                            cardsInCurrentSection = 0;
                        } else if (state === 'battlefield' && cardsInCurrentSection > 0) {
                            state = 'rune';
                            cardsInCurrentSection = 0;
                        }
                        continue;
                    }
                    
                    // Parse card lines (format: "3 Card Name" or "1 Card Name")
                    const match = line.match(/^(\d+)\s+(.+)$/);
                    if (match) {
                        const count = parseInt(match[1]);
                        const cardName = match[2];
                        const card = { name: cardName, count: count };
                        
                        if (state === 'legend') {
                            // Save legend card and extract champion name
                            newLegendCard = cardName;
                            if (cardName.includes(',')) {
                                championName = cardName.split(',')[0];
                            }
                        } else if (state === 'champion') {
                            // Champion card goes in main deck
                            newMainDeck.push(card);
                            if (!championName && cardName.includes(',')) {
                                championName = cardName.split(',')[0];
                            }
                            cardsInCurrentSection++;
                        } else if (state === 'main') {
                            newMainDeck.push(card);
                            cardsInCurrentSection++;
                        } else if (state === 'battlefield') {
                            newBattlefields.push(card);
                            cardsInCurrentSection++;
                        } else if (state === 'rune') {
                            newRunes.push(card);
                            cardsInCurrentSection++;
                        } else if (state === 'sideboard') {
                            newSideboard.push(card);
                        }
                    }
                }
                
                // Set deck name from champion if found
                if (championName && !deckName) {
                    setDeckName(championName);
                }
                
                // Update decks
                setLegendCard(newLegendCard);
                setMainDeck(newMainDeck);
                setSideboard(newSideboard);
                setBattlefields(newBattlefields);
                setRunes(newRunes);
                
                // Close import modal
                setShowImport(false);
                setImportText('');
                setActiveTab('deck');
            };

            const exportGuide = () => {
                let text = '';
                
                if (exportMode === 'full') {
                    text = `${deckName || 'Riftbound Deck'}\n\n`;
                    
                    if (legendCard) {
                        text += `LEGEND\n1 ${legendCard}\n\n`;
                    }
                    
                    text += `MAIN DECK (${mainDeck.reduce((sum, c) => sum + c.count, 0)})\n`;
                    mainDeck.forEach(card => text += `${card.count}x ${card.name}\n`);
                    
                    text += `\nSIDEBOARD (${sideboard.reduce((sum, c) => sum + c.count, 0)})\n`;
                    sideboard.forEach(card => text += `${card.count}x ${card.name}\n`);
                    
                    if (battlefields.length > 0) {
                        text += `\nBATTLEFIELDS (${battlefields.reduce((sum, c) => sum + c.count, 0)})\n`;
                        battlefields.forEach(card => text += `${card.count}x ${card.name}\n`);
                    }
                    
                    if (runes.length > 0) {
                        text += `\nRUNES (${runes.reduce((sum, c) => sum + c.count, 0)})\n`;
                        runes.forEach(card => text += `${card.count}x ${card.name}\n`);
                    }
                    
                    text += `\n--- SIDEBOARD GUIDE ---\n\n`;
                } else {
                    text = `${deckName || 'Riftbound Deck'} - SIDEBOARD GUIDE\n\n`;
                }
                
                matchups.forEach(matchup => {
                    text += `VS ${matchup.name.toUpperCase()}\n`;
                    if (matchup.playOrder) {
                        text += `Play Order: ${matchup.playOrder === 'second' ? 'Going Second' : 'Going First'}\n`;
                    }
                    if (matchup.battlefield) {
                        text += `Battlefield: ${matchup.battlefield}\n`;
                    }
                    
                    // Consolidate entries
                    const consolidated = matchup.sideboardPlan.reduce((acc, change) => {
                        const key = `${change.type}-${change.card}`;
                        if (!acc[key]) {
                            acc[key] = {
                                type: change.type,
                                card: change.card,
                                count: 0
                            };
                        }
                        acc[key].count += parseInt(change.count) || 0;
                        return acc;
                    }, {});
                    
                    // Output OUTs first
                    Object.values(consolidated).filter(c => c.type === 'out').forEach(change => {
                        text += `-${change.count} ${change.card}\n`;
                    });
                    // Then output INs
                    Object.values(consolidated).filter(c => c.type === 'in').forEach(change => {
                        text += `+${change.count} ${change.card}\n`;
                    });
                    text += `\n`;
                });
                
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${deckName || 'riftbound-deck'}-${exportMode === 'full' ? 'full' : 'sideboard'}-guide.txt`;
                a.click();
            };

            const exportGuidePDF = () => {
                let htmlContent = '';
                
                if (exportMode === 'full') {
                    // Full export with deck list
                    htmlContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <style>
                                @media print {
                                    @page { margin: 0.5in; }
                                }
                                body { 
                                    font-family: Arial, sans-serif; 
                                    padding: 20px; 
                                    color: #333; 
                                    font-size: 11pt;
                                }
                                h1 { 
                                    color: #6b46c1; 
                                    border-bottom: 2px solid #6b46c1; 
                                    padding-bottom: 8px; 
                                    margin-bottom: 15px;
                                    font-size: 18pt;
                                }
                                h2 { 
                                    color: #4a5568; 
                                    margin-top: 20px; 
                                    border-bottom: 1px solid #cbd5e0; 
                                    padding-bottom: 3px;
                                    font-size: 14pt;
                                }
                                .legend { 
                                    background: #fef3c7; 
                                    padding: 10px; 
                                    border-radius: 5px; 
                                    margin-bottom: 15px; 
                                    border: 1px solid #f59e0b;
                                    font-size: 10pt;
                                }
                                .section { 
                                    margin-bottom: 15px; 
                                    font-size: 10pt;
                                }
                                .card { 
                                    margin-left: 15px; 
                                    line-height: 1.3;
                                }
                                .total { 
                                    font-style: italic; 
                                    color: #718096; 
                                    margin-top: 3px;
                                    font-size: 9pt;
                                }
                                .matchup-grid {
                                    display: grid;
                                    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                                    gap: 12px;
                                    margin-top: 15px;
                                }
                                .matchup { 
                                    background: #f7fafc; 
                                    padding: 10px; 
                                    border-radius: 5px; 
                                    border-left: 3px solid #48bb78;
                                    break-inside: avoid;
                                    font-size: 10pt;
                                }
                                .matchup-title { 
                                    font-weight: bold; 
                                    color: #2f855a; 
                                    font-size: 11pt; 
                                    margin-bottom: 6px;
                                }
                                .matchup .card {
                                    margin-left: 10px;
                                    line-height: 1.4;
                                }
                                .sideboard-out { color: #e53e3e; }
                                .sideboard-in { color: #48bb78; }
                            </style>
                        </head>
                        <body>
                            <h1>${deckName || 'Riftbound Deck'}</h1>
                            
                            ${legendCard ? `<div class="legend"><strong>LEGEND:</strong> 1 ${legendCard}</div>` : ''}
                            
                            <div class="section">
                                <h2>Main Deck</h2>
                                ${mainDeck.map(card => `<div class="card">${card.count}x ${card.name}</div>`).join('')}
                                <div class="total">Total: ${mainDeck.reduce((sum, c) => sum + c.count, 0)} cards</div>
                            </div>
                            
                            <div class="section">
                                <h2>Sideboard</h2>
                                ${sideboard.map(card => `<div class="card">${card.count}x ${card.name}</div>`).join('')}
                                <div class="total">Total: ${sideboard.reduce((sum, c) => sum + c.count, 0)} cards</div>
                            </div>
                            
                            ${battlefields.length > 0 ? `
                            <div class="section">
                                <h2>Battlefields</h2>
                                ${battlefields.map(card => `<div class="card">${card.count}x ${card.name}</div>`).join('')}
                                <div class="total">Total: ${battlefields.reduce((sum, c) => sum + c.count, 0)} cards</div>
                            </div>
                            ` : ''}
                            
                            ${runes.length > 0 ? `
                            <div class="section">
                                <h2>Runes</h2>
                                ${runes.map(card => `<div class="card">${card.count}x ${card.name}</div>`).join('')}
                                <div class="total">Total: ${runes.reduce((sum, c) => sum + c.count, 0)} cards</div>
                            </div>
                            ` : ''}
                            
                            <h2>Sideboard Guide</h2>
                            <div class="matchup-grid">
                                ${matchups.map(matchup => {
                                    const consolidated = matchup.sideboardPlan.reduce((acc, change) => {
                                        const key = `${change.type}-${change.card}`;
                                        if (!acc[key]) {
                                            acc[key] = { type: change.type, card: change.card, count: 0 };
                                        }
                                        acc[key].count += parseInt(change.count) || 0;
                                        return acc;
                                    }, {});
                                    
                                    // Separate OUTs and INs
                                    const outs = Object.values(consolidated).filter(c => c.type === 'out');
                                    const ins = Object.values(consolidated).filter(c => c.type === 'in');
                                    
                                    return `
                                        <div class="matchup">
                                            <div class="matchup-title">
                                                VS ${matchup.name.toUpperCase()}
                                            </div>
                                            ${matchup.playOrder ? `<div style="color: #718096; font-size: 9pt; margin-bottom: 3px;">
                                                <strong>Play Order:</strong> ${matchup.playOrder === 'second' ? 'Going Second' : 'Going First'}
                                            </div>` : ''}
                                            ${matchup.battlefield ? `<div style="color: #f59e0b; font-size: 9pt; margin-bottom: 6px;">
                                                <strong>Battlefield:</strong> ${matchup.battlefield}
                                            </div>` : ''}
                                            ${outs.map(change => 
                                                `<div class="card sideboard-out">
                                                    -${change.count} ${change.card}
                                                </div>`
                                            ).join('')}
                                            ${ins.map(change => 
                                                `<div class="card sideboard-in">
                                                    +${change.count} ${change.card}
                                                </div>`
                                            ).join('')}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </body>
                        </html>
                    `;
                } else {
                    // Guide only export - optimized for compact display
                    htmlContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <style>
                                @media print {
                                    @page { margin: 0.5in; }
                                }
                                body { 
                                    font-family: Arial, sans-serif; 
                                    padding: 20px; 
                                    color: #333;
                                    font-size: 11pt;
                                }
                                h1 { 
                                    color: #6b46c1; 
                                    border-bottom: 2px solid #6b46c1; 
                                    padding-bottom: 10px; 
                                    margin-bottom: 20px;
                                    font-size: 20pt;
                                }
                                .matchup-grid {
                                    display: grid;
                                    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                                    gap: 15px;
                                }
                                .matchup { 
                                    background: #f7fafc; 
                                    padding: 12px; 
                                    border-radius: 6px; 
                                    border-left: 4px solid #48bb78;
                                    break-inside: avoid;
                                }
                                .matchup-title { 
                                    font-weight: bold; 
                                    color: #2f855a; 
                                    font-size: 12pt; 
                                    margin-bottom: 8px;
                                }
                                .card { 
                                    margin-left: 15px; 
                                    line-height: 1.5;
                                    font-size: 10pt;
                                }
                                .sideboard-out { color: #e53e3e; }
                                .sideboard-in { color: #48bb78; }
                            </style>
                        </head>
                        <body>
                            <h1>${deckName || 'Riftbound Deck'} - Sideboard Guide</h1>
                            
                            <div class="matchup-grid">
                                ${matchups.map(matchup => {
                                    const consolidated = matchup.sideboardPlan.reduce((acc, change) => {
                                        const key = `${change.type}-${change.card}`;
                                        if (!acc[key]) {
                                            acc[key] = { type: change.type, card: change.card, count: 0 };
                                        }
                                        acc[key].count += parseInt(change.count) || 0;
                                        return acc;
                                    }, {});
                                    
                                    // Separate OUTs and INs
                                    const outs = Object.values(consolidated).filter(c => c.type === 'out');
                                    const ins = Object.values(consolidated).filter(c => c.type === 'in');
                                    
                                    return `
                                        <div class="matchup">
                                            <div class="matchup-title">
                                                VS ${matchup.name.toUpperCase()}
                                            </div>
                                            ${matchup.playOrder ? `<div style="color: #718096; font-size: 9pt; margin-bottom: 3px;">
                                                <strong>Play Order:</strong> ${matchup.playOrder === 'second' ? 'Going Second' : 'Going First'}
                                            </div>` : ''}
                                            ${matchup.battlefield ? `<div style="color: #f59e0b; font-size: 9pt; margin-bottom: 6px;">
                                                <strong>Battlefield:</strong> ${matchup.battlefield}
                                            </div>` : ''}
                                            ${outs.map(change => 
                                                `<div class="card sideboard-out">
                                                    -${change.count} ${change.card}
                                                </div>`
                                            ).join('')}
                                            ${ins.map(change => 
                                                `<div class="card sideboard-in">
                                                    +${change.count} ${change.card}
                                                </div>`
                                            ).join('')}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </body>
                        </html>
                    `;
                }
                
                // Open in new window (no auto-print)
                const printWindow = window.open('', '_blank');
                printWindow.document.write(htmlContent);
                printWindow.document.close();
            };

            const exportGuideJPG = async () => {
                // Create a temporary div for rendering
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.width = '1200px';
                tempDiv.style.padding = '40px';
                tempDiv.style.background = 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)';
                tempDiv.style.fontFamily = 'Arial, sans-serif';
                document.body.appendChild(tempDiv);

                // Build the content
                let content = `
                    <div style="color: white; margin: 0; padding: 0;">
                        <style>
                            * { margin: 0; padding: 0; box-sizing: border-box; }
                        </style>
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 30px;">
                            <img src="https://cmsassets.rgpub.io/sanity/images/dsfx7636/riotbar/6222c5f038cd27fe9fc5aec17616e7ba0ea1c69e-2105x2105.svg?&h=50&fit=max" 
                                 style="width: 50px; height: 50px;" />
                            <h1 style="font-size: 32px; font-weight: bold; margin: 0;">${deckName || 'Riftbound Deck'}</h1>
                        </div>
                `;

                // If full mode, add deck lists
                if (exportMode === 'full') {
                    content += `<div style="margin-bottom: 30px;">`;
                    
                    if (legendCard) {
                        content += `
                            <div style="background: #fef3c7; color: #92400e; padding: 12px 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #f59e0b; line-height: 1.4;">
                                <strong style="margin: 0; padding: 0; line-height: 1.4;">LEGEND:</strong> 1 ${legendCard}
                            </div>
                        `;
                    }
                    
                    content += `
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">
                            <div style="background: #2d3748; padding: 15px; border-radius: 8px;">
                                <h2 style="font-size: 18px; font-weight: bold; color: #a78bfa; margin: 0 0 12px 0; line-height: 1;">Main Deck (${mainDeck.reduce((sum, c) => sum + c.count, 0)})</h2>
                                ${mainDeck.map(card => `<div style="font-size: 13px; margin-bottom: 3px; line-height: 1.4;">${card.count}x ${card.name}</div>`).join('')}
                            </div>
                            <div style="background: #2d3748; padding: 15px; border-radius: 8px;">
                                <h2 style="font-size: 18px; font-weight: bold; color: #48bb78; margin: 0 0 12px 0; line-height: 1;">Sideboard (${sideboard.reduce((sum, c) => sum + c.count, 0)})</h2>
                                ${sideboard.map(card => `<div style="font-size: 13px; margin-bottom: 3px; line-height: 1.4;">${card.count}x ${card.name}</div>`).join('')}
                            </div>
                        </div>
                    `;
                    
                    if (battlefields.length > 0 || runes.length > 0) {
                        content += `<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">`;
                        
                        if (battlefields.length > 0) {
                            content += `
                                <div style="background: #2d3748; padding: 15px; border-radius: 8px;">
                                    <h2 style="font-size: 18px; font-weight: bold; color: #f59e0b; margin: 0 0 12px 0; line-height: 1;">Battlefields (${battlefields.reduce((sum, c) => sum + c.count, 0)})</h2>
                                    ${battlefields.map(card => `<div style="font-size: 13px; margin-bottom: 3px; line-height: 1.4;">${card.count}x ${card.name}</div>`).join('')}
                                </div>
                            `;
                        }
                        
                        if (runes.length > 0) {
                            content += `
                                <div style="background: #2d3748; padding: 15px; border-radius: 8px;">
                                    <h2 style="font-size: 18px; font-weight: bold; color: #60a5fa; margin: 0 0 12px 0; line-height: 1;">Runes (${runes.reduce((sum, c) => sum + c.count, 0)})</h2>
                                    ${runes.map(card => `<div style="font-size: 13px; margin-bottom: 3px; line-height: 1.4;">${card.count}x ${card.name}</div>`).join('')}
                                </div>
                            `;
                        }
                        
                        content += `</div>`;
                    }
                    
                    content += `
                        <h2 style="font-size: 24px; font-weight: bold; margin-bottom: 20px; border-bottom: 2px solid #48bb78; padding-bottom: 10px;">Sideboard Guide</h2>
                    </div>`;
                }
                
                content += `<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">`;

                matchups.forEach(matchup => {
                    const consolidated = matchup.sideboardPlan.reduce((acc, change) => {
                        const key = `${change.type}-${change.card}`;
                        if (!acc[key]) {
                            acc[key] = { type: change.type, card: change.card, count: 0 };
                        }
                        acc[key].count += parseInt(change.count) || 0;
                        return acc;
                    }, {});

                    const outs = Object.values(consolidated).filter(c => c.type === 'out');
                    const ins = Object.values(consolidated).filter(c => c.type === 'in');

                    content += `
                        <div style="background: #2d3748; padding: 20px; border-radius: 8px; border-left: 4px solid #48bb78;">
                            <div style="font-size: 18px; font-weight: bold; color: #48bb78; margin-bottom: 5px;">
                                VS ${matchup.name.toUpperCase()}
                            </div>
                            ${matchup.playOrder ? `<div style="color: #a0aec0; font-size: 12px; margin-bottom: 3px;">
                                <strong>Play Order:</strong> ${matchup.playOrder === 'second' ? 'Going Second' : 'Going First'}
                            </div>` : ''}
                            ${matchup.battlefield ? `<div style="color: #f59e0b; font-size: 12px; margin-bottom: 12px;">
                                <strong>Battlefield:</strong> ${matchup.battlefield}
                            </div>` : ''}
                            ${outs.map(change => 
                                `<div style="color: #fc8181; font-size: 14px; margin-bottom: 4px;">-${change.count} ${change.card}</div>`
                            ).join('')}
                            ${ins.map(change => 
                                `<div style="color: #68d391; font-size: 14px; margin-bottom: 4px;">+${change.count} ${change.card}</div>`
                            ).join('')}
                        </div>
                    `;
                });

                content += `
                        </div>
                    </div>
                `;

                tempDiv.innerHTML = content;

                // Wait a moment for images to load
                await new Promise(resolve => setTimeout(resolve, 500));

                // Capture the div as canvas
                const canvas = await html2canvas(tempDiv, {
                    backgroundColor: null,
                    scale: 2, // Higher quality
                    logging: false
                });

                // Convert to JPG and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${deckName || 'riftbound-deck'}-${exportMode === 'full' ? 'full' : 'sideboard'}-guide.jpg`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    // Clean up
                    document.body.removeChild(tempDiv);
                }, 'image/jpeg', 0.95);
            };

            const currentlyEditing = editingMatchup || currentMatchup;

            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
                    <div className="max-w-6xl mx-auto">
                        <div className="bg-gradient-to-r from-gray-900 via-blue-950 to-gray-900 rounded-xl shadow-2xl p-8 mb-6 border border-blue-500/30">
                            <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-6">
                                <div className="flex-1">
                                    <div className="flex items-center gap-3 mb-4">
                                        <div className="w-12 h-12 bg-blue-600/20 rounded-lg flex items-center justify-center p-1 border border-blue-500/30">
                                            <img 
                                                src="https://cmsassets.rgpub.io/sanity/images/dsfx7636/riotbar/6222c5f038cd27fe9fc5aec17616e7ba0ea1c69e-2105x2105.svg?&h=50&fit=max" 
                                                alt="Riftbound Logo"
                                                className="w-full h-full object-contain"
                                            />
                                        </div>
                                        <h1 className="text-4xl font-bold text-white">
                                            Riftbound Sideboard Guide Generator
                                        </h1>
                                    </div>
                                    <input
                                        type="text"
                                        placeholder="Enter your deck name (e.g., Aggressive Ahri)"
                                        value={deckName}
                                        onChange={(e) => setDeckName(e.target.value)}
                                        className="w-full px-4 py-3 bg-gray-800/50 border border-blue-500/30 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-500/30 transition"
                                    />
                                </div>
                                <div className="flex flex-col gap-2 lg:min-w-[200px]">
                                    <button
                                        onClick={saveDeck}
                                        className="px-6 py-3 bg-gradient-to-r from-orange-600 to-orange-700 hover:from-orange-700 hover:to-orange-800 text-white rounded-lg font-semibold transition shadow-lg hover:shadow-orange-500/30 flex items-center justify-center gap-2"
                                    >
                                        <span>üíæ</span>
                                        <span>Save Deck</span>
                                    </button>
                                    <button
                                        onClick={() => setShowLoadDeck(true)}
                                        className="px-6 py-3 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white rounded-lg font-semibold transition shadow-lg hover:shadow-blue-500/30 flex items-center justify-center gap-2"
                                    >
                                        <span>üìÇ</span>
                                        <span>Load Deck</span>
                                    </button>
                                    <button
                                        onClick={() => setShowImport(true)}
                                        className="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white rounded-lg font-semibold transition shadow-lg hover:shadow-blue-400/30 flex items-center justify-center gap-2"
                                    >
                                        <span>üì•</span>
                                        <span>Import Decklist</span>
                                    </button>
                                    <button
                                        onClick={clearDeck}
                                        className="px-6 py-3 bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white rounded-lg font-semibold transition shadow-lg hover:shadow-gray-500/30 flex items-center justify-center gap-2"
                                    >
                                        <span>üóëÔ∏è</span>
                                        <span>Clear Deck</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="flex space-x-2 mb-4">
                            <button
                                onClick={() => setActiveTab('deck')}
                                className={`px-6 py-2 rounded font-semibold transition ${
                                    activeTab === 'deck' 
                                    ? 'bg-purple-600 text-white' 
                                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
                                }`}
                            >
                                Deck & Sideboard
                            </button>
                            <button
                                onClick={() => setActiveTab('matchups')}
                                className={`px-6 py-2 rounded font-semibold transition ${
                                    activeTab === 'matchups' 
                                    ? 'bg-purple-600 text-white' 
                                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
                                }`}
                            >
                                Matchups ({matchups.length})
                            </button>
                            {activeTab === 'matchup' && (
                                <button
                                    onClick={() => setActiveTab('matchups')}
                                    className="px-6 py-2 rounded font-semibold bg-gray-700 text-gray-300 hover:bg-gray-600"
                                >
                                    Cancel
                                </button>
                            )}
                        </div>

                        {activeTab === 'deck' && (
                            <div className="space-y-4">
                                {/* Legend Card */}
                                {legendCard && (
                                    <div className="bg-gray-900 rounded-lg p-4 border border-yellow-500">
                                        <div className="flex items-center justify-between">
                                            <div>
                                                <h3 className="text-sm font-semibold text-yellow-400 mb-1">LEGEND</h3>
                                                <p className="text-lg text-white font-bold">{legendCard}</p>
                                            </div>
                                            <button
                                                onClick={() => setLegendCard('')}
                                                className="text-red-400 hover:text-red-300 font-semibold px-3"
                                            >
                                                Clear
                                            </button>
                                        </div>
                                    </div>
                                )}

                                <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                    {/* Main Deck */}
                                    <div className="bg-gray-900 rounded-lg p-6 border border-purple-500">
                                        <h2 className="text-2xl font-bold text-purple-400 mb-4">Main Deck</h2>
                                        <div className="flex gap-2 mb-4">
                                            <input
                                                type="number"
                                                min="1"
                                                value={currentCard.count}
                                                onChange={(e) => setCurrentCard({ ...currentCard, count: e.target.value })}
                                                className="w-16 px-3 py-2 bg-gray-800 border border-gray-700 rounded text-white focus:outline-none focus:border-purple-500"
                                            />
                                            <input
                                                type="text"
                                                placeholder="Card name"
                                                value={currentCard.name}
                                                onChange={(e) => setCurrentCard({ ...currentCard, name: e.target.value })}
                                                onKeyPress={(e) => e.key === 'Enter' && addCard(true)}
                                                className="flex-1 px-4 py-2 bg-gray-800 border border-gray-700 rounded text-white placeholder-gray-500 focus:outline-none focus:border-purple-500"
                                            />
                                            <button
                                                onClick={() => addCard(true)}
                                                className="px-6 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded font-semibold transition"
                                            >
                                                Add
                                            </button>
                                        </div>
                                        <div className="space-y-2 max-h-96 overflow-y-auto">
                                            {mainDeck.map((card, index) => (
                                                <div key={index} className="flex justify-between items-center bg-gray-800 p-3 rounded border border-gray-700">
                                                    <span className="text-white">
                                                        <span className="text-purple-400 font-bold">{card.count}x</span> {card.name}
                                                    </span>
                                                    <button
                                                        onClick={() => removeCard(index, true)}
                                                        className="text-red-400 hover:text-red-300 font-semibold"
                                                    >
                                                        Remove
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                        <p className="text-gray-400 mt-4">
                                            Total: {mainDeck.reduce((sum, c) => sum + c.count, 0)} cards
                                        </p>
                                    </div>

                                    {/* Sideboard */}
                                    <div className="bg-gray-900 rounded-lg p-6 border border-blue-500">
                                        <h2 className="text-2xl font-bold text-blue-400 mb-4">Sideboard</h2>
                                        <div className="flex gap-2 mb-4">
                                            <input
                                                type="number"
                                                min="1"
                                                value={currentCard.count}
                                                onChange={(e) => setCurrentCard({ ...currentCard, count: e.target.value })}
                                                className="w-16 px-3 py-2 bg-gray-800 border border-gray-700 rounded text-white focus:outline-none focus:border-blue-500"
                                            />
                                            <input
                                                type="text"
                                                placeholder="Card name"
                                                value={currentCard.name}
                                                onChange={(e) => setCurrentCard({ ...currentCard, name: e.target.value })}
                                                onKeyPress={(e) => e.key === 'Enter' && addCard(false)}
                                                className="flex-1 px-4 py-2 bg-gray-800 border border-gray-700 rounded text-white placeholder-gray-500 focus:outline-none focus:border-blue-500"
                                            />
                                            <button
                                                onClick={() => addCard(false)}
                                                className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold transition"
                                            >
                                                Add
                                            </button>
                                        </div>
                                        <div className="space-y-2 max-h-96 overflow-y-auto">
                                            {sideboard.map((card, index) => (
                                                <div key={index} className="flex justify-between items-center bg-gray-800 p-3 rounded border border-gray-700">
                                                    <span className="text-white">
                                                        <span className="text-blue-400 font-bold">{card.count}x</span> {card.name}
                                                    </span>
                                                    <button
                                                        onClick={() => removeCard(index, false)}
                                                        className="text-red-400 hover:text-red-300 font-semibold"
                                                    >
                                                        Remove
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                        <p className="text-gray-400 mt-4">
                                            Total: {sideboard.reduce((sum, c) => sum + c.count, 0)} cards
                                        </p>
                                    </div>
                                </div>

                                <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                    {/* Battlefields */}
                                    <div className="bg-gray-900 rounded-lg p-6 border border-amber-500">
                                        <h2 className="text-xl font-bold text-amber-400 mb-4">Battlefields</h2>
                                        <div className="flex gap-2 mb-4">
                                            <input
                                                type="number"
                                                min="1"
                                                value={currentCard.count}
                                                onChange={(e) => setCurrentCard({ ...currentCard, count: e.target.value })}
                                                className="w-16 px-3 py-2 bg-gray-800 border border-gray-700 rounded text-white focus:outline-none focus:border-amber-500"
                                            />
                                            <input
                                                type="text"
                                                placeholder="Battlefield name"
                                                value={currentCard.name}
                                                onChange={(e) => setCurrentCard({ ...currentCard, name: e.target.value })}
                                                onKeyPress={(e) => {
                                                    if (e.key === 'Enter') {
                                                        if (currentCard.name.trim()) {
                                                            setBattlefields([...battlefields, { name: currentCard.name.trim(), count: parseInt(currentCard.count) || 1 }]);
                                                            setCurrentCard({ name: '', count: 1 });
                                                        }
                                                    }
                                                }}
                                                className="flex-1 px-4 py-2 bg-gray-800 border border-gray-700 rounded text-white placeholder-gray-500 focus:outline-none focus:border-amber-500"
                                            />
                                            <button
                                                onClick={() => {
                                                    if (currentCard.name.trim()) {
                                                        setBattlefields([...battlefields, { name: currentCard.name.trim(), count: parseInt(currentCard.count) || 1 }]);
                                                        setCurrentCard({ name: '', count: 1 });
                                                    }
                                                }}
                                                className="px-6 py-2 bg-amber-600 hover:bg-amber-700 text-white rounded font-semibold transition"
                                            >
                                                Add
                                            </button>
                                        </div>
                                        <div className="space-y-2">
                                            {battlefields.map((card, index) => (
                                                <div key={index} className="flex justify-between items-center bg-gray-800 p-3 rounded border border-gray-700">
                                                    <span className="text-white">
                                                        <span className="text-amber-400 font-bold">{card.count}x</span> {card.name}
                                                    </span>
                                                    <button
                                                        onClick={() => setBattlefields(battlefields.filter((_, i) => i !== index))}
                                                        className="text-red-400 hover:text-red-300 font-semibold"
                                                    >
                                                        Remove
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                        <p className="text-gray-400 mt-4">
                                            Total: {battlefields.reduce((sum, c) => sum + c.count, 0)} cards
                                        </p>
                                    </div>

                                    {/* Runes */}
                                    <div className="bg-gray-900 rounded-lg p-6 border border-cyan-500">
                                        <h2 className="text-xl font-bold text-cyan-400 mb-4">Runes</h2>
                                        <div className="flex gap-2 mb-4">
                                            <input
                                                type="number"
                                                min="1"
                                                value={currentCard.count}
                                                onChange={(e) => setCurrentCard({ ...currentCard, count: e.target.value })}
                                                className="w-16 px-3 py-2 bg-gray-800 border border-gray-700 rounded text-white focus:outline-none focus:border-cyan-500"
                                            />
                                            <input
                                                type="text"
                                                placeholder="Rune name"
                                                value={currentCard.name}
                                                onChange={(e) => setCurrentCard({ ...currentCard, name: e.target.value })}
                                                onKeyPress={(e) => {
                                                    if (e.key === 'Enter') {
                                                        if (currentCard.name.trim()) {
                                                            setRunes([...runes, { name: currentCard.name.trim(), count: parseInt(currentCard.count) || 1 }]);
                                                            setCurrentCard({ name: '', count: 1 });
                                                        }
                                                    }
                                                }}
                                                className="flex-1 px-4 py-2 bg-gray-800 border border-gray-700 rounded text-white placeholder-gray-500 focus:outline-none focus:border-cyan-500"
                                            />
                                            <button
                                                onClick={() => {
                                                    if (currentCard.name.trim()) {
                                                        setRunes([...runes, { name: currentCard.name.trim(), count: parseInt(currentCard.count) || 1 }]);
                                                        setCurrentCard({ name: '', count: 1 });
                                                    }
                                                }}
                                                className="px-6 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded font-semibold transition"
                                            >
                                                Add
                                            </button>
                                        </div>
                                        <div className="space-y-2">
                                            {runes.map((card, index) => (
                                                <div key={index} className="flex justify-between items-center bg-gray-800 p-3 rounded border border-gray-700">
                                                    <span className="text-white">
                                                        <span className="text-cyan-400 font-bold">{card.count}x</span> {card.name}
                                                    </span>
                                                    <button
                                                        onClick={() => setRunes(runes.filter((_, i) => i !== index))}
                                                        className="text-red-400 hover:text-red-300 font-semibold"
                                                    >
                                                        Remove
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                        <p className="text-gray-400 mt-4">
                                            Total: {runes.reduce((sum, c) => sum + c.count, 0)} cards
                                        </p>
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab === 'matchups' && (
                            <div className="bg-gray-900 rounded-lg p-6 border border-purple-500">
                                <div className="flex justify-between items-center mb-4">
                                    <button
                                        onClick={startNewMatchup}
                                        className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded font-semibold transition"
                                    >
                                        + New Matchup
                                    </button>
                                    {matchups.length > 0 && (
                                        <div className="flex items-center space-x-2">
                                            <select
                                                value={exportMode}
                                                onChange={(e) => setExportMode(e.target.value)}
                                                className="px-4 py-2 bg-gray-800 border border-gray-700 rounded text-white font-semibold focus:outline-none focus:border-purple-500"
                                            >
                                                <option value="guide">Guide Only</option>
                                                <option value="full">Full Deck + Guide</option>
                                            </select>
                                            <button
                                                onClick={exportGuide}
                                                className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold transition"
                                            >
                                                üìÑ Export TXT
                                            </button>
                                            <button
                                                onClick={exportGuidePDF}
                                                className="px-6 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded font-semibold transition"
                                            >
                                                üìë Export PDF
                                            </button>
                                            <button
                                                onClick={exportGuideJPG}
                                                className="px-6 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded font-semibold transition"
                                            >
                                                üì∏ Export JPG
                                            </button>
                                        </div>
                                    )}
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                    {matchups.map((matchup, index) => {
                                        // Consolidate sideboard plan entries
                                        const consolidated = matchup.sideboardPlan.reduce((acc, change) => {
                                            const key = `${change.type}-${change.card}`;
                                            if (!acc[key]) {
                                                acc[key] = {
                                                    type: change.type,
                                                    card: change.card,
                                                    count: 0
                                                };
                                            }
                                            acc[key].count += parseInt(change.count) || 0;
                                            return acc;
                                        }, {});
                                        
                                        return (
                                            <div key={index} className="bg-gray-800 p-4 rounded border border-gray-700 flex flex-col">
                                                <div className="mb-3">
                                                    <h3 className="text-xl font-bold text-green-400">
                                                        VS {matchup.name.toUpperCase()}
                                                    </h3>
                                                    {matchup.playOrder && (
                                                        <p className="text-sm text-gray-400 mt-1">
                                                            <strong>Play Order:</strong> {matchup.playOrder === 'second' ? 'Going Second' : 'Going First'}
                                                        </p>
                                                    )}
                                                    {matchup.battlefield && (
                                                        <p className="text-sm text-amber-400 mt-1">
                                                            <strong>Battlefield:</strong> {matchup.battlefield}
                                                        </p>
                                                    )}
                                                </div>
                                                <div className="space-y-1 mb-3 flex-1">
                                                    {/* Show OUTs first */}
                                                    {Object.values(consolidated).filter(c => c.type === 'out').map((change, i) => (
                                                        <div key={`out-${i}`} className="text-gray-300 text-sm">
                                                            <span className="text-red-400 font-semibold">
                                                                -{change.count}
                                                            </span> {change.card}
                                                        </div>
                                                    ))}
                                                    {/* Then show INs */}
                                                    {Object.values(consolidated).filter(c => c.type === 'in').map((change, i) => (
                                                        <div key={`in-${i}`} className="text-gray-300 text-sm">
                                                            <span className="text-green-400 font-semibold">
                                                                +{change.count}
                                                            </span> {change.card}
                                                        </div>
                                                    ))}
                                                </div>
                                                <div className="flex gap-2 pt-3 border-t border-gray-700">
                                                    <button
                                                        onClick={() => editMatchup(index)}
                                                        className="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm font-semibold transition"
                                                    >
                                                        ‚úèÔ∏è Edit
                                                    </button>
                                                    <button
                                                        onClick={() => deleteMatchup(index)}
                                                        className="flex-1 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded text-sm font-semibold transition"
                                                    >
                                                        üóëÔ∏è Delete
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {activeTab === 'matchup' && (
                            <div className="space-y-4">
                                <div className="bg-gray-900 rounded-lg p-6 border border-purple-500">
                                    <h2 className="text-2xl font-bold text-green-400 mb-4">
                                        {editingMatchup ? 'Edit Matchup' : 'New Matchup'}
                                    </h2>
                                    <div className="space-y-4">
                                        <input
                                            type="text"
                                            placeholder="Opponent Champion (e.g., Yasuo, Gwen, etc.)"
                                            value={currentlyEditing.name}
                                            onChange={(e) => {
                                                if (editingMatchup) {
                                                    setEditingMatchup({ ...editingMatchup, name: e.target.value });
                                                } else {
                                                    setCurrentMatchup({ ...currentMatchup, name: e.target.value });
                                                }
                                            }}
                                            className="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded text-white placeholder-gray-500 focus:outline-none focus:border-green-500"
                                        />
                                        
                                        <div>
                                            <label className="block text-sm font-semibold text-gray-400 mb-2">Play Order (Optional)</label>
                                            <div className="flex gap-4 items-center">
                                                <label className="flex items-center cursor-pointer">
                                                    <input
                                                        type="radio"
                                                        name="playOrder"
                                                        value=""
                                                        checked={!currentlyEditing.playOrder}
                                                        onChange={(e) => {
                                                            if (editingMatchup) {
                                                                setEditingMatchup({ ...editingMatchup, playOrder: '' });
                                                            } else {
                                                                setCurrentMatchup({ ...currentMatchup, playOrder: '' });
                                                            }
                                                        }}
                                                        className="mr-2"
                                                    />
                                                    <span className="text-white">Not Specified</span>
                                                </label>
                                                <label className="flex items-center cursor-pointer">
                                                    <input
                                                        type="radio"
                                                        name="playOrder"
                                                        value="first"
                                                        checked={currentlyEditing.playOrder === 'first'}
                                                        onChange={(e) => {
                                                            if (editingMatchup) {
                                                                setEditingMatchup({ ...editingMatchup, playOrder: e.target.value });
                                                            } else {
                                                                setCurrentMatchup({ ...currentMatchup, playOrder: e.target.value });
                                                            }
                                                        }}
                                                        className="mr-2"
                                                    />
                                                    <span className="text-white">Going First</span>
                                                </label>
                                                <label className="flex items-center cursor-pointer">
                                                    <input
                                                        type="radio"
                                                        name="playOrder"
                                                        value="second"
                                                        checked={currentlyEditing.playOrder === 'second'}
                                                        onChange={(e) => {
                                                            if (editingMatchup) {
                                                                setEditingMatchup({ ...editingMatchup, playOrder: e.target.value });
                                                            } else {
                                                                setCurrentMatchup({ ...currentMatchup, playOrder: e.target.value });
                                                            }
                                                        }}
                                                        className="mr-2"
                                                    />
                                                    <span className="text-white">Going Second</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
                                    {/* Main Deck Reference */}
                                    <div className="bg-gray-900 rounded-lg p-4 border border-red-500">
                                        <h3 className="text-lg font-bold text-red-400 mb-3 flex items-center">
                                            <span className="mr-2">‚¨ÖÔ∏è</span> Side Out From Main Deck
                                        </h3>
                                        <div className="space-y-1 max-h-96 overflow-y-auto">
                                            {(() => {
                                                // Calculate remaining cards after accounting for "out" changes
                                                const outCards = currentlyEditing.sideboardPlan
                                                    .filter(change => change.type === 'out')
                                                    .reduce((acc, change) => {
                                                        acc[change.card] = (acc[change.card] || 0) + parseInt(change.count);
                                                        return acc;
                                                    }, {});
                                                
                                                return mainDeck.map((card, index) => {
                                                    const usedCount = outCards[card.name] || 0;
                                                    const remainingCount = card.count - usedCount;
                                                    
                                                    if (remainingCount <= 0) return null;
                                                    
                                                    return (
                                                        <button
                                                            key={index}
                                                            onClick={() => {
                                                                const plan = editingMatchup ? [...editingMatchup.sideboardPlan] : [...currentMatchup.sideboardPlan];
                                                                plan.push({ type: 'out', card: card.name, count: 1 });
                                                                if (editingMatchup) {
                                                                    setEditingMatchup({ ...editingMatchup, sideboardPlan: plan });
                                                                } else {
                                                                    setCurrentMatchup({ ...currentMatchup, sideboardPlan: plan });
                                                                }
                                                            }}
                                                            className="w-full text-left px-3 py-2 bg-gray-800 hover:bg-gray-700 rounded text-sm text-white transition border border-gray-700 hover:border-red-500"
                                                        >
                                                            <span className="text-red-400 font-bold">{remainingCount}x</span> {card.name}
                                                        </button>
                                                    );
                                                }).filter(Boolean);
                                            })()}
                                        </div>
                                    </div>

                                    {/* Sideboard Plan */}
                                    <div className="bg-gray-900 rounded-lg p-4 border border-purple-500">
                                        <h3 className="text-lg font-bold text-purple-400 mb-3">Sideboard Plan</h3>
                                        <div className="space-y-2 max-h-96 overflow-y-auto">
                                            {currentlyEditing.sideboardPlan.length === 0 ? (
                                                <p className="text-gray-500 text-sm text-center py-8">
                                                    Click cards from Main Deck or Sideboard to add changes
                                                </p>
                                            ) : (
                                                (() => {
                                                    // Group changes by type and card name
                                                    const grouped = currentlyEditing.sideboardPlan.reduce((acc, change, index) => {
                                                        const key = `${change.type}-${change.card}`;
                                                        if (!acc[key]) {
                                                            acc[key] = {
                                                                type: change.type,
                                                                card: change.card,
                                                                totalCount: 0,
                                                                indices: []
                                                            };
                                                        }
                                                        acc[key].totalCount += parseInt(change.count) || 0;
                                                        acc[key].indices.push(index);
                                                        return acc;
                                                    }, {});
                                                    
                                                    return Object.values(grouped).map((group, groupIndex) => (
                                                        <div key={groupIndex} className="flex gap-2 items-center bg-gray-800 p-2 rounded border border-gray-700">
                                                            <span className={`px-2 py-1 rounded font-bold text-xs ${
                                                                group.type === 'out' ? 'bg-red-600' : 'bg-green-600'
                                                            }`}>
                                                                {group.type === 'out' ? 'OUT' : 'IN'}
                                                            </span>
                                                            <span className="text-white font-bold px-2">
                                                                {group.totalCount}x
                                                            </span>
                                                            <span className="flex-1 text-white text-sm">
                                                                {group.card}
                                                            </span>
                                                            <button
                                                                onClick={() => {
                                                                    // Remove all instances of this card/type combo
                                                                    const plan = editingMatchup 
                                                                        ? editingMatchup.sideboardPlan.filter((_, i) => !group.indices.includes(i))
                                                                        : currentMatchup.sideboardPlan.filter((_, i) => !group.indices.includes(i));
                                                                    
                                                                    if (editingMatchup) {
                                                                        setEditingMatchup({ ...editingMatchup, sideboardPlan: plan });
                                                                    } else {
                                                                        setCurrentMatchup({ ...currentMatchup, sideboardPlan: plan });
                                                                    }
                                                                }}
                                                                className="text-red-400 hover:text-red-300 font-bold px-2"
                                                            >
                                                                √ó
                                                            </button>
                                                        </div>
                                                    ));
                                                })()
                                            )}
                                        </div>
                                    </div>

                                    {/* Sideboard Reference */}
                                    <div className="bg-gray-900 rounded-lg p-4 border border-green-500">
                                        <h3 className="text-lg font-bold text-green-400 mb-3 flex items-center">
                                            Side In From Sideboard <span className="ml-2">‚û°Ô∏è</span>
                                        </h3>
                                        <div className="space-y-1 max-h-96 overflow-y-auto">
                                            {(() => {
                                                // Calculate remaining cards after accounting for "in" changes
                                                const inCards = currentlyEditing.sideboardPlan
                                                    .filter(change => change.type === 'in')
                                                    .reduce((acc, change) => {
                                                        acc[change.card] = (acc[change.card] || 0) + parseInt(change.count);
                                                        return acc;
                                                    }, {});
                                                
                                                return sideboard.map((card, index) => {
                                                    const usedCount = inCards[card.name] || 0;
                                                    const remainingCount = card.count - usedCount;
                                                    
                                                    if (remainingCount <= 0) return null;
                                                    
                                                    return (
                                                        <button
                                                            key={index}
                                                            onClick={() => {
                                                                const plan = editingMatchup ? [...editingMatchup.sideboardPlan] : [...currentMatchup.sideboardPlan];
                                                                plan.push({ type: 'in', card: card.name, count: 1 });
                                                                if (editingMatchup) {
                                                                    setEditingMatchup({ ...editingMatchup, sideboardPlan: plan });
                                                                } else {
                                                                    setCurrentMatchup({ ...currentMatchup, sideboardPlan: plan });
                                                                }
                                                            }}
                                                            className="w-full text-left px-3 py-2 bg-gray-800 hover:bg-gray-700 rounded text-sm text-white transition border border-gray-700 hover:border-green-500"
                                                        >
                                                            <span className="text-green-400 font-bold">{remainingCount}x</span> {card.name}
                                                        </button>
                                                    );
                                                }).filter(Boolean);
                                            })()}
                                        </div>
                                    </div>
                                </div>

                                {/* Battlefield Swap Section */}
                                {battlefields.length > 0 && (
                                    <div className="bg-gray-900 rounded-lg p-4 border border-amber-500">
                                        <h3 className="text-lg font-bold text-amber-400 mb-3">üó∫Ô∏è Battlefield Swap (Between Rounds)</h3>
                                        <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                                            {battlefields.map((bf, index) => (
                                                <button
                                                    key={index}
                                                    onClick={() => {
                                                        if (editingMatchup) {
                                                            setEditingMatchup({ ...editingMatchup, battlefield: bf.name });
                                                        } else {
                                                            setCurrentMatchup({ ...currentMatchup, battlefield: bf.name });
                                                        }
                                                    }}
                                                    className={`px-4 py-3 rounded text-sm font-semibold transition border-2 ${
                                                        (currentlyEditing.battlefield === bf.name)
                                                            ? 'bg-amber-600 border-amber-400 text-white'
                                                            : 'bg-gray-800 border-gray-700 text-gray-300 hover:border-amber-500'
                                                    }`}
                                                >
                                                    {bf.name}
                                                </button>
                                            ))}
                                        </div>
                                        <p className="text-xs text-gray-400 mt-2">Select which battlefield to use in this matchup</p>
                                    </div>
                                )}

                                <div className="bg-gray-900 rounded-lg p-4 border border-purple-500">
                                    <button
                                        onClick={saveMatchup}
                                        className="w-full px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded font-bold text-lg transition"
                                    >
                                        Save Matchup
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Load Deck Modal */}
                    {showLoadDeck && (
                        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                            <div className="bg-gray-900 rounded-lg p-6 max-w-2xl w-full border border-purple-500 max-h-[80vh] overflow-y-auto">
                                <h2 className="text-2xl font-bold text-purple-400 mb-4">Load Saved Deck</h2>
                                {savedDecks.length === 0 ? (
                                    <p className="text-gray-400 text-center py-8">
                                        No saved decks yet. Save your current deck to see it here!
                                    </p>
                                ) : (
                                    <div className="space-y-3">
                                        {savedDecks.map((deck, index) => (
                                            <div key={index} className="bg-gray-800 p-4 rounded border border-gray-700 hover:border-purple-500 transition">
                                                <div className="flex justify-between items-start mb-2">
                                                    <div className="flex-1">
                                                        <h3 className="text-lg font-bold text-white">{deck.name}</h3>
                                                        <p className="text-sm text-gray-400">
                                                            Saved: {new Date(deck.savedAt).toLocaleDateString()} {new Date(deck.savedAt).toLocaleTimeString()}
                                                        </p>
                                                        <p className="text-sm text-gray-400 mt-1">
                                                            Main: {deck.mainDeck.reduce((sum, c) => sum + c.count, 0)} cards | 
                                                            Sideboard: {deck.sideboard.reduce((sum, c) => sum + c.count, 0)} cards | 
                                                            Matchups: {deck.matchups.length}
                                                        </p>
                                                    </div>
                                                    <div className="flex gap-2 ml-4">
                                                        <button
                                                            onClick={() => loadDeck(deck)}
                                                            className="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded font-semibold transition"
                                                        >
                                                            Load
                                                        </button>
                                                        <button
                                                            onClick={() => deleteDeck(deck.name)}
                                                            className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded font-semibold transition"
                                                        >
                                                            Delete
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                                <button
                                    onClick={() => setShowLoadDeck(false)}
                                    className="w-full mt-4 px-6 py-3 bg-gray-700 hover:bg-gray-600 text-white rounded font-semibold transition"
                                >
                                    Close
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Import Modal */}
                    {showImport && (
                        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                            <div className="bg-gray-900 rounded-lg p-6 max-w-2xl w-full border border-purple-500">
                                <h2 className="text-2xl font-bold text-purple-400 mb-4">Import Deck List (Piltover Archive Only)</h2>
                                <p className="text-gray-400 mb-4">
                                    Paste your deck list from Piltover Archive. Copy the deck list directly from the site.
                                </p>
                                <textarea
                                    value={importText}
                                    onChange={(e) => setImportText(e.target.value)}
                                    placeholder="1 Ahri, Nine-Tailed Fox
3 Defy
3 Charm
...

Sideboard:
1 Rune Prison
2 Sprite Mother"
                                    className="w-full h-96 px-4 py-3 bg-gray-800 border border-gray-700 rounded text-white placeholder-gray-500 focus:outline-none focus:border-purple-500 font-mono text-sm"
                                />
                                <div className="flex gap-2 mt-4">
                                    <button
                                        onClick={importDeck}
                                        className="flex-1 px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded font-bold transition"
                                    >
                                        Import
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowImport(false);
                                            setImportText('');
                                        }}
                                        className="px-6 py-3 bg-gray-700 hover:bg-gray-600 text-white rounded font-semibold transition"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<RiftboundSideboardGuide />, document.getElementById('root'));
    </script>
</body>
</html>
